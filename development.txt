







Export the Android polygons.

Import the Android polygon database.


Button("Read and Write") {
    let data = Data("Test Message".utf8)
    let url = URL.documentsDirectory.appending(path: "message.txt")

    do {
        try data.write(to: url, options: [.atomic, .completeFileProtection])
        let input = try String(contentsOf: url)
        print(input)
    } catch {
        print(error.localizedDescription)
    }
}


https://levelup.gitconnected.com/swift-ios-file-import-and-export-choose-destination-folder-filename-and-save-to-files-app-3-ways-240770633fe1

https://www.hackingwithswift.com/quick-start/swiftui/how-to-export-files-using-fileexporter


https://levelup.gitconnected.com/swiftui-synchronize-store-files-documents-with-icloud-89b482361148

https://blog.devgenius.io/integrating-icloud-file-system-for-import-export-a-practical-guide-to-ios-swiftui-app-8d6d050ebce6







Import database with areas ready: Read the file, recreate local database, import data from file. Advantage: Refresh stuff.

Draw all areas covered on the map.
Check performance.










In the background, it only stores the waypoints in the database, and does not draw them on the map.


On moving to the foreground, it draw the waypoints on the map.
Distinguish them from the already drawn ones, perhaps by keeping locations in memory not yet drawn, and then only draw the not yet drawn ones.


Use a PRAGMA to make insertions very cheap and fast.






If it keeps losing the user location symbol on the map, then do one of these:
- [x] Write the annotation on the main thread
- [ ] Write our own symbol for the user location

















Have a way to designate an area covered.
The area can be edited.
Have OK and cancel, perhaps in the menu or the toolbar?
Stored that area in the database.
Export that database.
Import that database.
If a larger area is marked, all containing areas are wiped and replaced with the larger one.

















Make a label "About" and update it with diagnostics info, e.g. how many location updates were received, when the app goes to the foreground. Make sure to switch it off again.

Then update location delegate so on background it stores then locations in array only, or say, only count the number.
Then take the app along on a journey.
Then on move to foreground, update the "About" label with the location count.
If ok, then start drawing stuff on move to foreground.
That will check the entire route.

https://developer.apple.com/documentation/corelocation/handling-location-updates-in-the-background

https://stackoverflow.com/questions/52199463/ios-swift-background-location-monitoring

https://medium.com/simform-engineering/streamlined-location-updates-with-cllocationupdate-in-swift-wwdc23-2200ef71f845

While in the background, it receives the location updates,
stores the locations, but does not draw them on the map.
It will draw the cached locations on the map when it goes to the foreground.

It stores the track in the app settings, perhaps a database. This persists them.
If the app starts, and the track has not yet been drawn, it draw the track from the database.
This is more robust for crashes too.

If tracking and following are off, then make things very efficient in the background so it uses hardly any power.

In the background, it never follows the user that is, it does not move the map camera.











Mapkit overlays.
https://developer.apple.com/documentation/mapkit/mapkit-overlays








Once areas get covered, there's more and more annotations to draw.
Will that affect performance?
Mitigating measures:
* Draw the covered areas only in the visible area.
* Make a menu to call a procedure to join areas into one to reduce the number of areas.
* If drawing a new covered area, and it entirely overlays existing areas, then those existing areas will be removed and effectually replaced by the larger area. This may significantly reduce the areas if used wisely.





Have app background permissions, it won't draw on the map, it will just record the track, and draw the remainder on the map once it moves to the foreground.




Currently if the app moves to the foreground, it gives a red indication for the location. Switching tracking off and on again fixes that. Think of a better fix.
Perhaps it should once a minute or so, in the foreground, check the location and ensure it works.





Check on whether make locationManager.desiredAccuracy settable via menu.




The buttons and menus, should they be visible on the map itself?




Have four tracking states, one extra not displaying user location at all?




Have a button "Park (vehicle)" and implement it.



For receiving background location updates, does it need "Always location" permissions. Somewhere it says it does not need those if the background service is properly done.



Disable the developer journal production eventually?



Keep updating the polygon while dragging?
https://stackoverflow.com/questions/57401258/track-mkannotation-drag-as-it-moves



Later nog mogelijkheid maken om als het waren rond een gebied te "tekenen" met de vinger om een ruwe polylijn neer te zetten om te starten. Kan door te starten, dan met "tap" annotaties neer te zetten, en dan steeds verder, en dan knopje voor "klaar". Dit vereist een andere database layout.



Make an option to remove the last area marked ready in the database and from the map.
This is to remove an accidentally marked aread.







Export database functionality needed.






Make setting in the app that it has vertical layout as normal, and that it has portrait mode.
https://stackoverflow.com/questions/66037782/swiftui-how-do-i-lock-a-particular-view-in-portrait-mode-whilst-allowing-others

